KCPSM3  v1.30.      Ken Chapman (Xilinx-UK) 2005

The assembler for KCPSM3 Programmable State Machine

PASS 1 - Reading input PSM file

; KCPSM3 Program - Practice Picoblaze on Spartan-3A Starter Kit.
;
;
;
;
; The 8 LEDs provide a simple 'heart beat' counter driven by interrupts generated at
; one second intervals.
;
;
;**************************************************************************************
; Port definitions
;**************************************************************************************
;
;
;
CONSTANT LED_port, 80               ;8 simple LEDs. Is an OUTPUT port.
CONSTANT DATA_IN_PORT, 00         ;input data port. this is an INPUT port.
CONSTANT led0, 40
;**************************************************************************************
; Special Register usage
;**************************************************************************************
;
; No registers are given special names in this program.
;
;**************************************************************************************
; Scratch Pad Memory Locations
;**************************************************************************************
;
;
CONSTANT ISR_preserve_s0, 00        ;Preserve s0 contents during ISR
CONSTANT ISR_preserve_s1, 01        ;Preserve s1 contents during ISR
CONSTANT ISR_preserve_s2, 02        ;Preserve s2 contents during ISR
CONSTANT ISR_preserve_s3, 03        ;Preserve s3 contents during ISR
CONSTANT ISR_preserve_s4, 04        ;Preserve s3 contents during ISR
CONSTANT ISR_preserve_s5, 05        ;Preserve s3 contents during ISR
CONSTANT counter, 06        ;counts down from 255 to 0
CONSTANT addition, 07        ;LSB of accumulator
;
CONSTANT addition2, 08            ;MSB of accumulator
;
;**************************************************************************************
; Useful data constants
;**************************************************************************************
;
;
; Constant to define a software delay of 1us. This must be adjusted to reflect the
; clock applied to KCPSM3. Every instruction executes in 2 clock cycles making the
; calculation highly predictable. The '6' in the following equation even allows for
; 'CALL delay_1us' instruction in the initiating code.
;
; delay_1us_constant =  (clock_rate - 6)/4       Where 'clock_rate' is in MHz
;
; Example: For a 50MHz clock the constant value is (50-6)/4 = 11  (0B Hex).
; For clock rates below 10MHz the value of 1 must be used and the operation will
; become lower than intended. Interrupts may effect the timing of software based
; delays.
;
CONSTANT delay_1us_constant, 0B
;
;
;
; ASCII table
;
CONSTANT character_a, 61
CONSTANT character_b, 62
CONSTANT character_c, 63
CONSTANT character_d, 64
CONSTANT character_e, 65
CONSTANT character_f, 66
CONSTANT character_g, 67
CONSTANT character_h, 68
CONSTANT character_i, 69
CONSTANT character_j, 6A
CONSTANT character_k, 6B
CONSTANT character_l, 6C
CONSTANT character_m, 6D
CONSTANT character_n, 6E
CONSTANT character_o, 6F
CONSTANT character_p, 70
CONSTANT character_q, 71
CONSTANT character_r, 72
CONSTANT character_s, 73
CONSTANT character_t, 74
CONSTANT character_u, 75
CONSTANT character_v, 76
CONSTANT character_w, 77
CONSTANT character_x, 78
CONSTANT character_y, 79
CONSTANT character_z, 7A
CONSTANT character_A, 41
CONSTANT character_B, 42
CONSTANT character_C, 43
CONSTANT character_D, 44
CONSTANT character_E, 45
CONSTANT character_F, 46
CONSTANT character_G, 47
CONSTANT character_H, 48
CONSTANT character_I, 49
CONSTANT character_J, 4A
CONSTANT character_K, 4B
CONSTANT character_L, 4C
CONSTANT character_M, 4D
CONSTANT character_N, 4E
CONSTANT character_O, 4F
CONSTANT character_P, 50
CONSTANT character_Q, 51
CONSTANT character_R, 52
CONSTANT character_S, 53
CONSTANT character_T, 54
CONSTANT character_U, 55
CONSTANT character_V, 56
CONSTANT character_W, 57
CONSTANT character_X, 58
CONSTANT character_Y, 59
CONSTANT character_Z, 5A
CONSTANT character_0, 30
CONSTANT character_1, 31
CONSTANT character_2, 32
CONSTANT character_3, 33
CONSTANT character_4, 34
CONSTANT character_5, 35
CONSTANT character_6, 36
CONSTANT character_7, 37
CONSTANT character_8, 38
CONSTANT character_9, 39
CONSTANT character_colon, 3A
CONSTANT character_stop, 2E
CONSTANT character_semi_colon, 3B
CONSTANT character_minus, 2D
CONSTANT character_divide, 2F       ;'/'
CONSTANT character_plus, 2B
CONSTANT character_comma, 2C
CONSTANT character_less_than, 3C
CONSTANT character_greater_than, 3E
CONSTANT character_equals, 3D
CONSTANT character_space, 20
CONSTANT character_CR, 0D           ;carriage return
CONSTANT character_question, 3F     ;'?'
CONSTANT character_dollar, 24
CONSTANT character_exclaim, 21      ;'!'
CONSTANT character_BS, 08           ;Back Space command character
;
;
;
;
;
;**************************************************************************************
; Initialise the system
;**************************************************************************************
;
cold_start: LOAD s0, 00                         ;clear 1 second counter and clear LEDs
;STORE s0, LED_port
OUTPUT s0, LED_port
;
ENABLE INTERRUPT                    ;enable one second heart beat
;**************************************************************************************
; Main program
;**************************************************************************************
;
; Display welcome message for design
;
main_program: CALL delay_1s           ;toggle on
LOAD s6, 01;  used a register than is not in use by ISR
OUTPUT s6, led0
;wait 1 second
CALL delay_1s; toggle every second
LOAD s6, 00;  turn off
OUTPUT s6, led0
JUMP main_program;
;**************************************************************************************
; Software delay routines
;**************************************************************************************
;
; Delay of 1us.
;
; Constant value 'delay_1us_constant' reflects the clock applied to KCPSM3. Every
; instruction executes in 2 clock cycles making the calculation highly predictable.
; The '6' in the following equation allows for the 'CALL delay_1us' instruction used
; in the initiating code. Interrupts may effect software derived delays.
;
; delay_1us_constant =  (clock_rate - 6)/4       Where 'clock_rate' is in MHz
;
; Registers used s0
;
delay_1us: LOAD s0, delay_1us_constant
wait_1us: SUB s0, 01
JUMP NZ, wait_1us
RETURN
;
; Delay of 40us.
;
; Registers used s0, s1
;
delay_40us: LOAD s1, 28                         ;40 x 1us = 40us
wait_40us: CALL delay_1us
SUB s1, 01
JUMP NZ, wait_40us
RETURN
;
;
; Delay of 1ms.
;
; Registers used s0, s1, s2
;
delay_1ms: LOAD s2, 19                         ;25 x 40us = 1ms
wait_1ms: CALL delay_40us
SUB s2, 01
JUMP NZ, wait_1ms
RETURN
;
; Delay of 20ms.
;
; Delay of 20ms used during initialisation.
;
; Registers used s0, s1, s2, s3
;
delay_20ms: LOAD s3, 14                         ;20 x 1ms = 20ms
wait_20ms: CALL delay_1ms
SUB s3, 01
JUMP NZ, wait_20ms
RETURN
delay_100ms: LOAD s3, 64                         ;100 x 1ms = 20ms
wait_100ms: CALL delay_1ms
SUB s3, 01
JUMP NZ, wait_100ms
RETURN
;
; Delay of approximately 1 second.
;
; Registers used s0, s1, s2, s3, s4
;
delay_1s: LOAD s4, 32                         ;50 x 20ms = 1000ms
wait_1s: CALL delay_20ms
SUB s4, 01
JUMP NZ, wait_1s
RETURN
;
;
;
;**************************************************************************************
; Interrupt Service Routine (ISR)
;**************************************************************************************
;
; The interrupt is used purely to provide a 1 second heart beat binary counter pattern
; on the 8 LEDs.
;gave myself 5 registers to use during ISR
ISR: STORE s0, ISR_preserve_s0           ;preserve register  //input value of new data in s0
STORE s1, ISR_preserve_s1           ;preserve register  //new value in s1
STORE s2, ISR_preserve_s2           ;preserve register
STORE s3, ISR_preserve_s3           ;preserve register
STORE s4, ISR_preserve_s4           ;preserve register
STORE s5, ISR_preserve_s5           ;preserve register  // counter for 256
FETCH s5, counter
FETCH s1, addition
FETCH s2, addition2
;JUMP countdown
INPUT s0, DATA_IN_PORT
TEST s0, 80
JUMP NZ, 2scompliment
JUMP additionstep
2scompliment:   XOR s0, FF   ;; Xoring the bits of s0 to find 2s compliment
ADD s0, 01  ;; Add 1 to finish finding 2's compliment
JUMP additionstep
additionstep:
ADD s1,s0
ADDCY s2,00
JUMP inccount
inccount:       COMPARE s5,FF
JUMP Z, displayresult
ADD s5, 01
JUMP ISR_done
displayresult:
TEST s2,80
JUMP Z, SIX
LOAD s3, FF
OUTPUT s3, LED_port
JUMP restart
SIX:
TEST s2,40
JUMP Z, FIVE
LOAD s3, FE
OUTPUT s3, LED_port
JUMP restart
FIVE:
TEST s2, 20
JUMP Z, FOUR
LOAD s3, FC
OUTPUT s3, LED_port
JUMP restart
FOUR:
TEST s2, 10
JUMP Z, THREE
LOAD s3, F8
OUTPUT s3, LED_port
JUMP restart
THREE:
TEST s2,08
JUMP Z, TWO
LOAD s3, F0
OUTPUT s3, LED_port
JUMP restart
TWO:
TEST s2,04
JUMP Z, ONE
LOAD s3, E0
OUTPUT s3, LED_port
JUMP restart
ONE:
TEST s2,02
JUMP Z, ZERO
LOAD s3, C0
OUTPUT s3, LED_port
JUMP restart
ZERO:
TEST s2,01
JUMP Z, ISR_done
LOAD s3, 80
OUTPUT s3, LED_port
JUMP restart
ISR_done:
STORE s5, counter
STORE s1, addition
STORE s2, addition2
FETCH s0, ISR_preserve_s0           ;restore register
FETCH s1, ISR_preserve_s1           ;restore register
FETCH s2, ISR_preserve_s2           ;restore register
FETCH s3, ISR_preserve_s3           ;restore register
FETCH s4, ISR_preserve_s4           ;restore register
FETCH s5, ISR_preserve_s5           ;restore register
RETURNI ENABLE                      ; RETURNI ENABLE determines the future ability of interrupt
restart:
LOAD s3, 00              ;; doing the process 256 times
STORE s3, counter
STORE s3, addition
STORE s3, addition2
JUMP ISR_done
;
;
;**************************************************************************************
; Interrupt Vector
;**************************************************************************************
;
ADDRESS 3FF
JUMP ISR
;
;

PASS 2 - Testing Instructions

; KCPSM3 Program - Practice Picoblaze on Spartan-3A Starter Kit.
;
;
;
;
; The 8 LEDs provide a simple 'heart beat' counter driven by interrupts generated at
; one second intervals.
;
;
;**************************************************************************************
; Port definitions
;**************************************************************************************
;
;
;
CONSTANT LED_port, 80;8 simple LEDs. Is an OUTPUT port.
CONSTANT DATA_IN_PORT, 00;input data port. this is an INPUT port.
CONSTANT led0, 40
;**************************************************************************************
; Special Register usage
;**************************************************************************************
;
; No registers are given special names in this program.
;
;**************************************************************************************
; Scratch Pad Memory Locations
;**************************************************************************************
;
;
CONSTANT ISR_preserve_s0, 00;Preserve s0 contents during ISR
CONSTANT ISR_preserve_s1, 01;Preserve s1 contents during ISR
CONSTANT ISR_preserve_s2, 02;Preserve s2 contents during ISR
CONSTANT ISR_preserve_s3, 03;Preserve s3 contents during ISR
CONSTANT ISR_preserve_s4, 04;Preserve s3 contents during ISR
CONSTANT ISR_preserve_s5, 05;Preserve s3 contents during ISR
CONSTANT counter, 06;counts down from 255 to 0
CONSTANT addition, 07;LSB of accumulator
;
CONSTANT addition2, 08;MSB of accumulator
;
;**************************************************************************************
; Useful data constants
;**************************************************************************************
;
;
; Constant to define a software delay of 1us. This must be adjusted to reflect the
; clock applied to KCPSM3. Every instruction executes in 2 clock cycles making the
; calculation highly predictable. The '6' in the following equation even allows for
; 'CALL delay_1us' instruction in the initiating code.
;
; delay_1us_constant =  (clock_rate - 6)/4       Where 'clock_rate' is in MHz
;
; Example: For a 50MHz clock the constant value is (50-6)/4 = 11  (0B Hex).
; For clock rates below 10MHz the value of 1 must be used and the operation will
; become lower than intended. Interrupts may effect the timing of software based
; delays.
;
CONSTANT delay_1us_constant, 0B
;
;
;
; ASCII table
;
CONSTANT character_a, 61
CONSTANT character_b, 62
CONSTANT character_c, 63
CONSTANT character_d, 64
CONSTANT character_e, 65
CONSTANT character_f, 66
CONSTANT character_g, 67
CONSTANT character_h, 68
CONSTANT character_i, 69
CONSTANT character_j, 6A
CONSTANT character_k, 6B
CONSTANT character_l, 6C
CONSTANT character_m, 6D
CONSTANT character_n, 6E
CONSTANT character_o, 6F
CONSTANT character_p, 70
CONSTANT character_q, 71
CONSTANT character_r, 72
CONSTANT character_s, 73
CONSTANT character_t, 74
CONSTANT character_u, 75
CONSTANT character_v, 76
CONSTANT character_w, 77
CONSTANT character_x, 78
CONSTANT character_y, 79
CONSTANT character_z, 7A
CONSTANT character_A, 41
CONSTANT character_B, 42
CONSTANT character_C, 43
CONSTANT character_D, 44
CONSTANT character_E, 45
CONSTANT character_F, 46
CONSTANT character_G, 47
CONSTANT character_H, 48
CONSTANT character_I, 49
CONSTANT character_J, 4A
CONSTANT character_K, 4B
CONSTANT character_L, 4C
CONSTANT character_M, 4D
CONSTANT character_N, 4E
CONSTANT character_O, 4F
CONSTANT character_P, 50
CONSTANT character_Q, 51
CONSTANT character_R, 52
CONSTANT character_S, 53
CONSTANT character_T, 54
CONSTANT character_U, 55
CONSTANT character_V, 56
CONSTANT character_W, 57
CONSTANT character_X, 58
CONSTANT character_Y, 59
CONSTANT character_Z, 5A
CONSTANT character_0, 30
CONSTANT character_1, 31
CONSTANT character_2, 32
CONSTANT character_3, 33
CONSTANT character_4, 34
CONSTANT character_5, 35
CONSTANT character_6, 36
CONSTANT character_7, 37
CONSTANT character_8, 38
CONSTANT character_9, 39
CONSTANT character_colon, 3A
CONSTANT character_stop, 2E
CONSTANT character_semi_colon, 3B
CONSTANT character_minus, 2D
CONSTANT character_divide, 2F;'/'
CONSTANT character_plus, 2B
CONSTANT character_comma, 2C
CONSTANT character_less_than, 3C
CONSTANT character_greater_than, 3E
CONSTANT character_equals, 3D
CONSTANT character_space, 20
CONSTANT character_CR, 0D;carriage return
CONSTANT character_question, 3F;'?'
CONSTANT character_dollar, 24
CONSTANT character_exclaim, 21;'!'
CONSTANT character_BS, 08;Back Space command character
;
;
;
;
;
;**************************************************************************************
; Initialise the system
;**************************************************************************************
;
cold_start: LOAD s0, 00;clear 1 second counter and clear LEDs
;STORE s0, LED_port
OUTPUT s0, LED_port
;
ENABLE INTERRUPT;enable one second heart beat
;**************************************************************************************
; Main program
;**************************************************************************************
;
; Display welcome message for design
;
main_program: CALL delay_1s;toggle on
LOAD s6, 01;  used a register than is not in use by ISR
OUTPUT s6, led0
;wait 1 second
CALL delay_1s; toggle every second
LOAD s6, 00;  turn off
OUTPUT s6, led0
JUMP main_program;
;**************************************************************************************
; Software delay routines
;**************************************************************************************
;
; Delay of 1us.
;
; Constant value 'delay_1us_constant' reflects the clock applied to KCPSM3. Every
; instruction executes in 2 clock cycles making the calculation highly predictable.
; The '6' in the following equation allows for the 'CALL delay_1us' instruction used
; in the initiating code. Interrupts may effect software derived delays.
;
; delay_1us_constant =  (clock_rate - 6)/4       Where 'clock_rate' is in MHz
;
; Registers used s0
;
delay_1us: LOAD s0, delay_1us_constant
wait_1us: SUB s0, 01
JUMP NZ, wait_1us
RETURN
;
; Delay of 40us.
;
; Registers used s0, s1
;
delay_40us: LOAD s1, 28;40 x 1us = 40us
wait_40us: CALL delay_1us
SUB s1, 01
JUMP NZ, wait_40us
RETURN
;
;
; Delay of 1ms.
;
; Registers used s0, s1, s2
;
delay_1ms: LOAD s2, 19;25 x 40us = 1ms
wait_1ms: CALL delay_40us
SUB s2, 01
JUMP NZ, wait_1ms
RETURN
;
; Delay of 20ms.
;
; Delay of 20ms used during initialisation.
;
; Registers used s0, s1, s2, s3
;
delay_20ms: LOAD s3, 14;20 x 1ms = 20ms
wait_20ms: CALL delay_1ms
SUB s3, 01
JUMP NZ, wait_20ms
RETURN
delay_100ms: LOAD s3, 64;100 x 1ms = 20ms
wait_100ms: CALL delay_1ms
SUB s3, 01
JUMP NZ, wait_100ms
RETURN
;
; Delay of approximately 1 second.
;
; Registers used s0, s1, s2, s3, s4
;
delay_1s: LOAD s4, 32;50 x 20ms = 1000ms
wait_1s: CALL delay_20ms
SUB s4, 01
JUMP NZ, wait_1s
RETURN
;
;
;
;**************************************************************************************
; Interrupt Service Routine (ISR)
;**************************************************************************************
;
; The interrupt is used purely to provide a 1 second heart beat binary counter pattern
; on the 8 LEDs.
;gave myself 5 registers to use during ISR
ISR: STORE s0, ISR_preserve_s0;preserve register  //input value of new data in s0
STORE s1, ISR_preserve_s1;preserve register  //new value in s1
STORE s2, ISR_preserve_s2;preserve register
STORE s3, ISR_preserve_s3;preserve register
STORE s4, ISR_preserve_s4;preserve register
STORE s5, ISR_preserve_s5;preserve register  // counter for 256
FETCH s5, counter
FETCH s1, addition
FETCH s2, addition2
;JUMP countdown
INPUT s0, DATA_IN_PORT
TEST s0, 80
JUMP NZ, 2scompliment
JUMP additionstep
2scompliment: XOR s0, FF;; Xoring the bits of s0 to find 2s compliment
ADD s0, 01;; Add 1 to finish finding 2's compliment
JUMP additionstep
additionstep: 
ADD s1, s0
ADDCY s2, 00
JUMP inccount
inccount: COMPARE s5, FF
JUMP Z, displayresult
ADD s5, 01
JUMP ISR_done
displayresult: 
TEST s2, 80
JUMP Z, SIX
LOAD s3, FF
OUTPUT s3, LED_port
JUMP restart
SIX: 
TEST s2, 40
JUMP Z, FIVE
LOAD s3, FE
OUTPUT s3, LED_port
JUMP restart
FIVE: 
TEST s2, 20
JUMP Z, FOUR
LOAD s3, FC
OUTPUT s3, LED_port
JUMP restart
FOUR: 
TEST s2, 10
JUMP Z, THREE
LOAD s3, F8
OUTPUT s3, LED_port
JUMP restart
THREE: 
TEST s2, 08
JUMP Z, TWO
LOAD s3, F0
OUTPUT s3, LED_port
JUMP restart
TWO: 
TEST s2, 04
JUMP Z, ONE
LOAD s3, E0
OUTPUT s3, LED_port
JUMP restart
ONE: 
TEST s2, 02
JUMP Z, ZERO
LOAD s3, C0
OUTPUT s3, LED_port
JUMP restart
ZERO: 
TEST s2, 01
JUMP Z, ISR_done
LOAD s3, 80
OUTPUT s3, LED_port
JUMP restart
ISR_done: 
STORE s5, counter
STORE s1, addition
STORE s2, addition2
FETCH s0, ISR_preserve_s0;restore register
FETCH s1, ISR_preserve_s1;restore register
FETCH s2, ISR_preserve_s2;restore register
FETCH s3, ISR_preserve_s3;restore register
FETCH s4, ISR_preserve_s4;restore register
FETCH s5, ISR_preserve_s5;restore register
RETURNI ENABLE; RETURNI ENABLE determines the future ability of interrupt
restart: 
LOAD s3, 00;; doing the process 256 times
STORE s3, counter
STORE s3, addition
STORE s3, addition2
JUMP ISR_done
;
;
;**************************************************************************************
; Interrupt Vector
;**************************************************************************************
;
ADDRESS 3FF
JUMP ISR
;
;

PASS 3 - Resolving addresses and line labels

000 ; KCPSM3 Program - Practice Picoblaze on Spartan-3A Starter Kit.
000 ;
000 ;
000 ;
000 ;
000 
; The 8 LEDs provide a simple 'heart beat' counter driven by interrupts generated at
000 ; one second intervals.
000 ;
000 ;
000 
;**************************************************************************************
000 ; Port definitions
000 
;**************************************************************************************
000 ;
000 ;
000 ;
000 CONSTANT LED_port, 80;8 simple LEDs. Is an OUTPUT port.
000 CONSTANT DATA_IN_PORT, 00;input data port. this is an INPUT port.
000 CONSTANT led0, 40
000 
;**************************************************************************************
000 ; Special Register usage
000 
;**************************************************************************************
000 ;
000 ; No registers are given special names in this program.
000 ;
000 
;**************************************************************************************
000 ; Scratch Pad Memory Locations
000 
;**************************************************************************************
000 ;
000 ;
000 CONSTANT ISR_preserve_s0, 00;Preserve s0 contents during ISR
000 CONSTANT ISR_preserve_s1, 01;Preserve s1 contents during ISR
000 CONSTANT ISR_preserve_s2, 02;Preserve s2 contents during ISR
000 CONSTANT ISR_preserve_s3, 03;Preserve s3 contents during ISR
000 CONSTANT ISR_preserve_s4, 04;Preserve s3 contents during ISR
000 CONSTANT ISR_preserve_s5, 05;Preserve s3 contents during ISR
000 CONSTANT counter, 06;counts down from 255 to 0
000 CONSTANT addition, 07;LSB of accumulator
000 ;
000 CONSTANT addition2, 08;MSB of accumulator
000 ;
000 
;**************************************************************************************
000 ; Useful data constants
000 
;**************************************************************************************
000 ;
000 ;
000 
; Constant to define a software delay of 1us. This must be adjusted to reflect the
000 
; clock applied to KCPSM3. Every instruction executes in 2 clock cycles making the
000 
; calculation highly predictable. The '6' in the following equation even allows for
000 ; 'CALL delay_1us' instruction in the initiating code.
000 ;
000 
; delay_1us_constant =  (clock_rate - 6)/4       Where 'clock_rate' is in MHz
000 ;
000 ; Example: For a 50MHz clock the constant value is (50-6)/4 = 11  (0B Hex).
000 
; For clock rates below 10MHz the value of 1 must be used and the operation will
000 
; become lower than intended. Interrupts may effect the timing of software based
000 ; delays.
000 ;
000 CONSTANT delay_1us_constant, 0B
000 ;
000 ;
000 ;
000 ; ASCII table
000 ;
000 CONSTANT character_a, 61
000 CONSTANT character_b, 62
000 CONSTANT character_c, 63
000 CONSTANT character_d, 64
000 CONSTANT character_e, 65
000 CONSTANT character_f, 66
000 CONSTANT character_g, 67
000 CONSTANT character_h, 68
000 CONSTANT character_i, 69
000 CONSTANT character_j, 6A
000 CONSTANT character_k, 6B
000 CONSTANT character_l, 6C
000 CONSTANT character_m, 6D
000 CONSTANT character_n, 6E
000 CONSTANT character_o, 6F
000 CONSTANT character_p, 70
000 CONSTANT character_q, 71
000 CONSTANT character_r, 72
000 CONSTANT character_s, 73
000 CONSTANT character_t, 74
000 CONSTANT character_u, 75
000 CONSTANT character_v, 76
000 CONSTANT character_w, 77
000 CONSTANT character_x, 78
000 CONSTANT character_y, 79
000 CONSTANT character_z, 7A
000 CONSTANT character_A, 41
000 CONSTANT character_B, 42
000 CONSTANT character_C, 43
000 CONSTANT character_D, 44
000 CONSTANT character_E, 45
000 CONSTANT character_F, 46
000 CONSTANT character_G, 47
000 CONSTANT character_H, 48
000 CONSTANT character_I, 49
000 CONSTANT character_J, 4A
000 CONSTANT character_K, 4B
000 CONSTANT character_L, 4C
000 CONSTANT character_M, 4D
000 CONSTANT character_N, 4E
000 CONSTANT character_O, 4F
000 CONSTANT character_P, 50
000 CONSTANT character_Q, 51
000 CONSTANT character_R, 52
000 CONSTANT character_S, 53
000 CONSTANT character_T, 54
000 CONSTANT character_U, 55
000 CONSTANT character_V, 56
000 CONSTANT character_W, 57
000 CONSTANT character_X, 58
000 CONSTANT character_Y, 59
000 CONSTANT character_Z, 5A
000 CONSTANT character_0, 30
000 CONSTANT character_1, 31
000 CONSTANT character_2, 32
000 CONSTANT character_3, 33
000 CONSTANT character_4, 34
000 CONSTANT character_5, 35
000 CONSTANT character_6, 36
000 CONSTANT character_7, 37
000 CONSTANT character_8, 38
000 CONSTANT character_9, 39
000 CONSTANT character_colon, 3A
000 CONSTANT character_stop, 2E
000 CONSTANT character_semi_colon, 3B
000 CONSTANT character_minus, 2D
000 CONSTANT character_divide, 2F;'/'
000 CONSTANT character_plus, 2B
000 CONSTANT character_comma, 2C
000 CONSTANT character_less_than, 3C
000 CONSTANT character_greater_than, 3E
000 CONSTANT character_equals, 3D
000 CONSTANT character_space, 20
000 CONSTANT character_CR, 0D;carriage return
000 CONSTANT character_question, 3F;'?'
000 CONSTANT character_dollar, 24
000 CONSTANT character_exclaim, 21;'!'
000 CONSTANT character_BS, 08;Back Space command character
000 ;
000 ;
000 ;
000 ;
000 ;
000 
;**************************************************************************************
000 ; Initialise the system
000 
;**************************************************************************************
000 ;
000 cold_start: LOAD s0, 00;clear 1 second counter and clear LEDs
001 ;STORE s0, LED_port
001 OUTPUT s0, LED_port
002 ;
002 ENABLE INTERRUPT;enable one second heart beat
003 
;**************************************************************************************
003 ; Main program
003 
;**************************************************************************************
003 ;
003 ; Display welcome message for design
003 ;
003 main_program: CALL delay_1s;toggle on
004 LOAD s6, 01;  used a register than is not in use by ISR
005 OUTPUT s6, led0
006 ;wait 1 second
006 CALL delay_1s; toggle every second
007 LOAD s6, 00;  turn off
008 OUTPUT s6, led0
009 JUMP main_program;
00A 
;**************************************************************************************
00A ; Software delay routines
00A 
;**************************************************************************************
00A ;
00A ; Delay of 1us.
00A ;
00A 
; Constant value 'delay_1us_constant' reflects the clock applied to KCPSM3. Every
00A 
; instruction executes in 2 clock cycles making the calculation highly predictable.
00A 
; The '6' in the following equation allows for the 'CALL delay_1us' instruction used
00A ; in the initiating code. Interrupts may effect software derived delays.
00A ;
00A 
; delay_1us_constant =  (clock_rate - 6)/4       Where 'clock_rate' is in MHz
00A ;
00A ; Registers used s0
00A ;
00A delay_1us: LOAD s0, delay_1us_constant
00B wait_1us: SUB s0, 01
00C JUMP NZ, wait_1us
00D RETURN
00E ;
00E ; Delay of 40us.
00E ;
00E ; Registers used s0, s1
00E ;
00E delay_40us: LOAD s1, 28;40 x 1us = 40us
00F wait_40us: CALL delay_1us
010 SUB s1, 01
011 JUMP NZ, wait_40us
012 RETURN
013 ;
013 ;
013 ; Delay of 1ms.
013 ;
013 ; Registers used s0, s1, s2
013 ;
013 delay_1ms: LOAD s2, 19;25 x 40us = 1ms
014 wait_1ms: CALL delay_40us
015 SUB s2, 01
016 JUMP NZ, wait_1ms
017 RETURN
018 ;
018 ; Delay of 20ms.
018 ;
018 ; Delay of 20ms used during initialisation.
018 ;
018 ; Registers used s0, s1, s2, s3
018 ;
018 delay_20ms: LOAD s3, 14;20 x 1ms = 20ms
019 wait_20ms: CALL delay_1ms
01A SUB s3, 01
01B JUMP NZ, wait_20ms
01C RETURN
01D delay_100ms: LOAD s3, 64;100 x 1ms = 20ms
01E wait_100ms: CALL delay_1ms
01F SUB s3, 01
020 JUMP NZ, wait_100ms
021 RETURN
022 ;
022 ; Delay of approximately 1 second.
022 ;
022 ; Registers used s0, s1, s2, s3, s4
022 ;
022 delay_1s: LOAD s4, 32;50 x 20ms = 1000ms
023 wait_1s: CALL delay_20ms
024 SUB s4, 01
025 JUMP NZ, wait_1s
026 RETURN
027 ;
027 ;
027 ;
027 
;**************************************************************************************
027 ; Interrupt Service Routine (ISR)
027 
;**************************************************************************************
027 ;
027 
; The interrupt is used purely to provide a 1 second heart beat binary counter pattern
027 ; on the 8 LEDs.
027 ;gave myself 5 registers to use during ISR
027 
ISR: STORE s0, ISR_preserve_s0;preserve register  //input value of new data in s0
028 STORE s1, ISR_preserve_s1;preserve register  //new value in s1
029 STORE s2, ISR_preserve_s2;preserve register
02A STORE s3, ISR_preserve_s3;preserve register
02B STORE s4, ISR_preserve_s4;preserve register
02C STORE s5, ISR_preserve_s5;preserve register  // counter for 256
02D FETCH s5, counter
02E FETCH s1, addition
02F FETCH s2, addition2
030 ;JUMP countdown
030 INPUT s0, DATA_IN_PORT
031 TEST s0, 80
032 JUMP NZ, 2scompliment
033 JUMP additionstep
034 2scompliment: XOR s0, FF;; Xoring the bits of s0 to find 2s compliment
035 ADD s0, 01;; Add 1 to finish finding 2's compliment
036 JUMP additionstep
037 additionstep: 
037 ADD s1, s0
038 ADDCY s2, 00
039 JUMP inccount
03A inccount: COMPARE s5, FF
03B JUMP Z, displayresult
03C ADD s5, 01
03D JUMP ISR_done
03E displayresult: 
03E TEST s2, 80
03F JUMP Z, SIX
040 LOAD s3, FF
041 OUTPUT s3, LED_port
042 JUMP restart
043 SIX: 
043 TEST s2, 40
044 JUMP Z, FIVE
045 LOAD s3, FE
046 OUTPUT s3, LED_port
047 JUMP restart
048 FIVE: 
048 TEST s2, 20
049 JUMP Z, FOUR
04A LOAD s3, FC
04B OUTPUT s3, LED_port
04C JUMP restart
04D FOUR: 
04D TEST s2, 10
04E JUMP Z, THREE
04F LOAD s3, F8
050 OUTPUT s3, LED_port
051 JUMP restart
052 THREE: 
052 TEST s2, 08
053 JUMP Z, TWO
054 LOAD s3, F0
055 OUTPUT s3, LED_port
056 JUMP restart
057 TWO: 
057 TEST s2, 04
058 JUMP Z, ONE
059 LOAD s3, E0
05A OUTPUT s3, LED_port
05B JUMP restart
05C ONE: 
05C TEST s2, 02
05D JUMP Z, ZERO
05E LOAD s3, C0
05F OUTPUT s3, LED_port
060 JUMP restart
061 ZERO: 
061 TEST s2, 01
062 JUMP Z, ISR_done
063 LOAD s3, 80
064 OUTPUT s3, LED_port
065 JUMP restart
066 ISR_done: 
066 STORE s5, counter
067 STORE s1, addition
068 STORE s2, addition2
069 FETCH s0, ISR_preserve_s0;restore register
06A FETCH s1, ISR_preserve_s1;restore register
06B FETCH s2, ISR_preserve_s2;restore register
06C FETCH s3, ISR_preserve_s3;restore register
06D FETCH s4, ISR_preserve_s4;restore register
06E FETCH s5, ISR_preserve_s5;restore register
06F RETURNI ENABLE; RETURNI ENABLE determines the future ability of interrupt
070 restart: 
070 LOAD s3, 00;; doing the process 256 times
071 STORE s3, counter
072 STORE s3, addition
073 STORE s3, addition2
074 JUMP ISR_done
075 ;
075 ;
075 
;**************************************************************************************
075 ; Interrupt Vector
075 
;**************************************************************************************
075 ;
075 ADDRESS 3FF
3FF JUMP ISR
3FF ;
3FF ;

PASS 4 - Resolving Operands

000 ; KCPSM3 Program - Practice Picoblaze on Spartan-3A Starter Kit.
000 ;
000 ;
000 ;
000 ;
000 
; The 8 LEDs provide a simple 'heart beat' counter driven by interrupts generated at
000 ; one second intervals.
000 ;
000 ;
000 
;**************************************************************************************
000 ; Port definitions
000 
;**************************************************************************************
000 ;
000 ;
000 ;
000 CONSTANT LED_port, 80;8 simple LEDs. Is an OUTPUT port.
000 CONSTANT DATA_IN_PORT, 00;input data port. this is an INPUT port.
000 CONSTANT led0, 40
000 
;**************************************************************************************
000 ; Special Register usage
000 
;**************************************************************************************
000 ;
000 ; No registers are given special names in this program.
000 ;
000 
;**************************************************************************************
000 ; Scratch Pad Memory Locations
000 
;**************************************************************************************
000 ;
000 ;
000 CONSTANT ISR_preserve_s0, 00;Preserve s0 contents during ISR
000 CONSTANT ISR_preserve_s1, 01;Preserve s1 contents during ISR
000 CONSTANT ISR_preserve_s2, 02;Preserve s2 contents during ISR
000 CONSTANT ISR_preserve_s3, 03;Preserve s3 contents during ISR
000 CONSTANT ISR_preserve_s4, 04;Preserve s3 contents during ISR
000 CONSTANT ISR_preserve_s5, 05;Preserve s3 contents during ISR
000 CONSTANT counter, 06;counts down from 255 to 0
000 CONSTANT addition, 07;LSB of accumulator
000 ;
000 CONSTANT addition2, 08;MSB of accumulator
000 ;
000 
;**************************************************************************************
000 ; Useful data constants
000 
;**************************************************************************************
000 ;
000 ;
000 
; Constant to define a software delay of 1us. This must be adjusted to reflect the
000 
; clock applied to KCPSM3. Every instruction executes in 2 clock cycles making the
000 
; calculation highly predictable. The '6' in the following equation even allows for
000 ; 'CALL delay_1us' instruction in the initiating code.
000 ;
000 
; delay_1us_constant =  (clock_rate - 6)/4       Where 'clock_rate' is in MHz
000 ;
000 ; Example: For a 50MHz clock the constant value is (50-6)/4 = 11  (0B Hex).
000 
; For clock rates below 10MHz the value of 1 must be used and the operation will
000 
; become lower than intended. Interrupts may effect the timing of software based
000 ; delays.
000 ;
000 CONSTANT delay_1us_constant, 0B
000 ;
000 ;
000 ;
000 ; ASCII table
000 ;
000 CONSTANT character_a, 61
000 CONSTANT character_b, 62
000 CONSTANT character_c, 63
000 CONSTANT character_d, 64
000 CONSTANT character_e, 65
000 CONSTANT character_f, 66
000 CONSTANT character_g, 67
000 CONSTANT character_h, 68
000 CONSTANT character_i, 69
000 CONSTANT character_j, 6A
000 CONSTANT character_k, 6B
000 CONSTANT character_l, 6C
000 CONSTANT character_m, 6D
000 CONSTANT character_n, 6E
000 CONSTANT character_o, 6F
000 CONSTANT character_p, 70
000 CONSTANT character_q, 71
000 CONSTANT character_r, 72
000 CONSTANT character_s, 73
000 CONSTANT character_t, 74
000 CONSTANT character_u, 75
000 CONSTANT character_v, 76
000 CONSTANT character_w, 77
000 CONSTANT character_x, 78
000 CONSTANT character_y, 79
000 CONSTANT character_z, 7A
000 CONSTANT character_A, 41
000 CONSTANT character_B, 42
000 CONSTANT character_C, 43
000 CONSTANT character_D, 44
000 CONSTANT character_E, 45
000 CONSTANT character_F, 46
000 CONSTANT character_G, 47
000 CONSTANT character_H, 48
000 CONSTANT character_I, 49
000 CONSTANT character_J, 4A
000 CONSTANT character_K, 4B
000 CONSTANT character_L, 4C
000 CONSTANT character_M, 4D
000 CONSTANT character_N, 4E
000 CONSTANT character_O, 4F
000 CONSTANT character_P, 50
000 CONSTANT character_Q, 51
000 CONSTANT character_R, 52
000 CONSTANT character_S, 53
000 CONSTANT character_T, 54
000 CONSTANT character_U, 55
000 CONSTANT character_V, 56
000 CONSTANT character_W, 57
000 CONSTANT character_X, 58
000 CONSTANT character_Y, 59
000 CONSTANT character_Z, 5A
000 CONSTANT character_0, 30
000 CONSTANT character_1, 31
000 CONSTANT character_2, 32
000 CONSTANT character_3, 33
000 CONSTANT character_4, 34
000 CONSTANT character_5, 35
000 CONSTANT character_6, 36
000 CONSTANT character_7, 37
000 CONSTANT character_8, 38
000 CONSTANT character_9, 39
000 CONSTANT character_colon, 3A
000 CONSTANT character_stop, 2E
000 CONSTANT character_semi_colon, 3B
000 CONSTANT character_minus, 2D
000 CONSTANT character_divide, 2F;'/'
000 CONSTANT character_plus, 2B
000 CONSTANT character_comma, 2C
000 CONSTANT character_less_than, 3C
000 CONSTANT character_greater_than, 3E
000 CONSTANT character_equals, 3D
000 CONSTANT character_space, 20
000 CONSTANT character_CR, 0D;carriage return
000 CONSTANT character_question, 3F;'?'
000 CONSTANT character_dollar, 24
000 CONSTANT character_exclaim, 21;'!'
000 CONSTANT character_BS, 08;Back Space command character
000 ;
000 ;
000 ;
000 ;
000 ;
000 
;**************************************************************************************
000 ; Initialise the system
000 
;**************************************************************************************
000 ;
000 cold_start: LOAD s0, 00;clear 1 second counter and clear LEDs
001 ;STORE s0, LED_port
001 OUTPUT s0, LED_port
002 ;
002 ENABLE INTERRUPT;enable one second heart beat
003 
;**************************************************************************************
003 ; Main program
003 
;**************************************************************************************
003 ;
003 ; Display welcome message for design
003 ;
003 main_program: CALL delay_1s;toggle on
004 LOAD s6, 01;  used a register than is not in use by ISR
005 OUTPUT s6, led0
006 ;wait 1 second
006 CALL delay_1s; toggle every second
007 LOAD s6, 00;  turn off
008 OUTPUT s6, led0
009 JUMP main_program;
00A 
;**************************************************************************************
00A ; Software delay routines
00A 
;**************************************************************************************
00A ;
00A ; Delay of 1us.
00A ;
00A 
; Constant value 'delay_1us_constant' reflects the clock applied to KCPSM3. Every
00A 
; instruction executes in 2 clock cycles making the calculation highly predictable.
00A 
; The '6' in the following equation allows for the 'CALL delay_1us' instruction used
00A ; in the initiating code. Interrupts may effect software derived delays.
00A ;
00A 
; delay_1us_constant =  (clock_rate - 6)/4       Where 'clock_rate' is in MHz
00A ;
00A ; Registers used s0
00A ;
00A delay_1us: LOAD s0, delay_1us_constant
00B wait_1us: SUB s0, 01
00C JUMP NZ, wait_1us
00D RETURN
00E ;
00E ; Delay of 40us.
00E ;
00E ; Registers used s0, s1
00E ;
00E delay_40us: LOAD s1, 28;40 x 1us = 40us
00F wait_40us: CALL delay_1us
010 SUB s1, 01
011 JUMP NZ, wait_40us
012 RETURN
013 ;
013 ;
013 ; Delay of 1ms.
013 ;
013 ; Registers used s0, s1, s2
013 ;
013 delay_1ms: LOAD s2, 19;25 x 40us = 1ms
014 wait_1ms: CALL delay_40us
015 SUB s2, 01
016 JUMP NZ, wait_1ms
017 RETURN
018 ;
018 ; Delay of 20ms.
018 ;
018 ; Delay of 20ms used during initialisation.
018 ;
018 ; Registers used s0, s1, s2, s3
018 ;
018 delay_20ms: LOAD s3, 14;20 x 1ms = 20ms
019 wait_20ms: CALL delay_1ms
01A SUB s3, 01
01B JUMP NZ, wait_20ms
01C RETURN
01D delay_100ms: LOAD s3, 64;100 x 1ms = 20ms
01E wait_100ms: CALL delay_1ms
01F SUB s3, 01
020 JUMP NZ, wait_100ms
021 RETURN
022 ;
022 ; Delay of approximately 1 second.
022 ;
022 ; Registers used s0, s1, s2, s3, s4
022 ;
022 delay_1s: LOAD s4, 32;50 x 20ms = 1000ms
023 wait_1s: CALL delay_20ms
024 SUB s4, 01
025 JUMP NZ, wait_1s
026 RETURN
027 ;
027 ;
027 ;
027 
;**************************************************************************************
027 ; Interrupt Service Routine (ISR)
027 
;**************************************************************************************
027 ;
027 
; The interrupt is used purely to provide a 1 second heart beat binary counter pattern
027 ; on the 8 LEDs.
027 ;gave myself 5 registers to use during ISR
027 
ISR: STORE s0, ISR_preserve_s0;preserve register  //input value of new data in s0
028 STORE s1, ISR_preserve_s1;preserve register  //new value in s1
029 STORE s2, ISR_preserve_s2;preserve register
02A STORE s3, ISR_preserve_s3;preserve register
02B STORE s4, ISR_preserve_s4;preserve register
02C STORE s5, ISR_preserve_s5;preserve register  // counter for 256
02D FETCH s5, counter
02E FETCH s1, addition
02F FETCH s2, addition2
030 ;JUMP countdown
030 INPUT s0, DATA_IN_PORT
031 TEST s0, 80
032 JUMP NZ, 2scompliment
033 JUMP additionstep
034 2scompliment: XOR s0, FF;; Xoring the bits of s0 to find 2s compliment
035 ADD s0, 01;; Add 1 to finish finding 2's compliment
036 JUMP additionstep
037 additionstep: 
037 ADD s1, s0
038 ADDCY s2, 00
039 JUMP inccount
03A inccount: COMPARE s5, FF
03B JUMP Z, displayresult
03C ADD s5, 01
03D JUMP ISR_done
03E displayresult: 
03E TEST s2, 80
03F JUMP Z, SIX
040 LOAD s3, FF
041 OUTPUT s3, LED_port
042 JUMP restart
043 SIX: 
043 TEST s2, 40
044 JUMP Z, FIVE
045 LOAD s3, FE
046 OUTPUT s3, LED_port
047 JUMP restart
048 FIVE: 
048 TEST s2, 20
049 JUMP Z, FOUR
04A LOAD s3, FC
04B OUTPUT s3, LED_port
04C JUMP restart
04D FOUR: 
04D TEST s2, 10
04E JUMP Z, THREE
04F LOAD s3, F8
050 OUTPUT s3, LED_port
051 JUMP restart
052 THREE: 
052 TEST s2, 08
053 JUMP Z, TWO
054 LOAD s3, F0
055 OUTPUT s3, LED_port
056 JUMP restart
057 TWO: 
057 TEST s2, 04
058 JUMP Z, ONE
059 LOAD s3, E0
05A OUTPUT s3, LED_port
05B JUMP restart
05C ONE: 
05C TEST s2, 02
05D JUMP Z, ZERO
05E LOAD s3, C0
05F OUTPUT s3, LED_port
060 JUMP restart
061 ZERO: 
061 TEST s2, 01
062 JUMP Z, ISR_done
063 LOAD s3, 80
064 OUTPUT s3, LED_port
065 JUMP restart
066 ISR_done: 
066 STORE s5, counter
067 STORE s1, addition
068 STORE s2, addition2
069 FETCH s0, ISR_preserve_s0;restore register
06A FETCH s1, ISR_preserve_s1;restore register
06B FETCH s2, ISR_preserve_s2;restore register
06C FETCH s3, ISR_preserve_s3;restore register
06D FETCH s4, ISR_preserve_s4;restore register
06E FETCH s5, ISR_preserve_s5;restore register
06F RETURNI ENABLE; RETURNI ENABLE determines the future ability of interrupt
070 restart: 
070 LOAD s3, 00;; doing the process 256 times
071 STORE s3, counter
072 STORE s3, addition
073 STORE s3, addition2
074 JUMP ISR_done
075 ;
075 ;
075 
;**************************************************************************************
075 ; Interrupt Vector
075 
;**************************************************************************************
075 ;
3FF ADDRESS 3FF
3FF JUMP ISR
3FF ;
3FF ;

PASS 5 - Writing reformatted PSM file
           lb3pico.fmt

PASS 6 - Writing assembler log file
           lb3pico.log

PASS 7 - Writing coefficient file
           lb3pico.coe

PASS 8 - Writing VHDL memory definition file
           lb3pico.vhd

PASS 9 - Writing Verilog memory definition file
           lb3pico.v

PASS 10 - Writing System Generator memory definition file
           lb3pico.m

PASS 11 - Writing memory definition files
           lb3pico.hex
           lb3pico.dec
           lb3pico.mem


KCPSM3 successful.

KCPSM3 complete.

